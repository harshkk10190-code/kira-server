<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>KIRA QUANTUM V4.3</title>
<link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@500;700;900&family=Rajdhani:wght@500;600;700&display=swap" rel="stylesheet">
<style>
    /* ================== QUANTUM UI ================== */
    :root {
        --bg: #050508;
        --glass: rgba(15, 15, 25, 0.7);
        --glass-border: rgba(255, 255, 255, 0.1);
        --cyan: #00f3ff;
        --purple: #bc13fe;
        --green: #00ff9d;
        --red: #ff003c;
        --yellow: #ffea00;
    }

    body { 
        margin: 0; background: var(--bg); color: #fff; 
        font-family: 'Rajdhani', sans-serif; 
        background-image: 
            radial-gradient(circle at 15% 50%, rgba(188, 19, 254, 0.15), transparent 35%),
            radial-gradient(circle at 85% 30%, rgba(0, 243, 255, 0.15), transparent 35%);
        min-height: 100vh; display: flex; flex-direction: column; align-items: center; padding: 20px;
        overflow-x: hidden;
    }

    .header { text-align: center; margin-bottom: 20px; }
    .title { 
        font-family: 'Orbitron', sans-serif; font-size: 28px; font-weight: 900; letter-spacing: 3px; margin: 0;
        background: linear-gradient(90deg, var(--cyan), var(--purple));
        -webkit-background-clip: text; -webkit-text-fill-color: transparent;
        text-shadow: 0 0 20px rgba(0, 243, 255, 0.4);
    }
    .subtitle { font-size: 13px; color: var(--cyan); letter-spacing: 2px; font-weight: 700; text-transform: uppercase; animation: pulse 2s infinite; margin-top: 5px; }

    .dashboard { width: 100%; max-width: 420px; display: flex; flex-direction: column; gap: 15px; }

    .glass-card {
        background: var(--glass); backdrop-filter: blur(20px); -webkit-backdrop-filter: blur(20px);
        border: 1px solid var(--glass-border); border-radius: 16px; padding: 20px;
        box-shadow: 0 10px 40px rgba(0,0,0,0.6), inset 0 1px 0 rgba(255,255,255,0.2);
    }

    .metrics { display: flex; justify-content: space-between; align-items: center; border-bottom: 1px solid var(--glass-border); padding-bottom: 15px; margin-bottom: 15px; }
    .metric-box { text-align: center; width: 48%; }
    .m-label { font-size: 11px; color: #aaa; text-transform: uppercase; font-weight: 700; letter-spacing: 1px; }
    .m-val { font-family: 'Orbitron', sans-serif; font-size: 22px; color: #fff; margin-top: 5px; text-shadow: 0 0 10px rgba(255,255,255,0.2); }

    .pred-container { text-align: center; padding: 10px 0; }
    .pred-target { font-size: 46px; font-family: 'Orbitron', sans-serif; font-weight: 900; margin: 10px 0; text-transform: uppercase; }
    
    .c-WAIT { color: #888; text-shadow: none; animation: pulse 1.5s infinite; }
    .c-BIG { color: var(--yellow); text-shadow: 0 0 25px rgba(255, 234, 0, 0.5); }
    .c-SMALL { color: var(--purple); text-shadow: 0 0 25px rgba(188, 19, 254, 0.5); }

    .prob-bar-bg { width: 100%; height: 10px; background: rgba(0,0,0,0.6); border-radius: 10px; overflow: hidden; margin-top: 15px; border: 1px solid var(--glass-border); position: relative; }
    .prob-bar-fill { height: 100%; width: 0%; background: linear-gradient(90deg, var(--cyan), var(--purple)); transition: 0.8s cubic-bezier(0.4, 0, 0.2, 1); box-shadow: 0 0 10px var(--purple); }

    .terminal {
        background: rgba(0, 0, 5, 0.85); border: 1px solid var(--glass-border); border-radius: 12px;
        padding: 15px; height: 260px; overflow-y: auto; font-family: monospace; font-size: 12px;
        color: #bbb; box-shadow: inset 0 5px 25px rgba(0,0,0,0.9); margin-top: 5px;
    }
    .log-row { margin-bottom: 8px; line-height: 1.4; border-bottom: 1px dashed rgba(255,255,255,0.05); padding-bottom: 4px; }
    .t-time { color: #666; }
    .t-info { color: var(--cyan); }
    .t-success { color: var(--green); text-shadow: 0 0 8px rgba(0,255,157,0.4); font-weight: bold; }
    .t-warn { color: var(--yellow); }
    .t-err { color: var(--red); font-weight: bold; }
    .t-mem { color: var(--purple); font-style: italic; }

    .btn-reset { 
        background: rgba(255, 0, 60, 0.1); border: 1px solid rgba(255, 0, 60, 0.4); color: var(--red); 
        padding: 12px; border-radius: 8px; font-family: 'Rajdhani', sans-serif; font-size: 15px; font-weight: 700; 
        cursor: pointer; width: 100%; margin-top: 15px; transition: 0.3s; letter-spacing: 1px;
    }
    .btn-reset:hover { background: rgba(255, 0, 60, 0.2); box-shadow: 0 0 15px rgba(255, 0, 60, 0.4); }

    @keyframes pulse { 50% { opacity: 0.4; } }
    ::-webkit-scrollbar { width: 4px; }
    ::-webkit-scrollbar-thumb { background: var(--cyan); border-radius: 10px; }

    #blocker { display: none; position: fixed; inset: 0; background: #000; z-index: 99999; flex-direction: column; justify-content: center; align-items: center; text-align: center; padding: 20px; }
    #blocker h1 { color: #ff003c; font-family: 'Orbitron', sans-serif; font-size: 40px; text-shadow: 0 0 20px red; }
</style>
</head>
<body>

    <div id="blocker">
        <h1>ğŸ›‘ STOP!</h1>
        <p style="font-size: 18px; color: #fff; line-height: 1.5;">You are opening this in a File Manager.<br>Background scripts and memory are <b>BLOCKED</b> here.<br><br><span style="color:#00f3ff; font-weight:bold; font-size:22px;">Please open this file using GOOGLE CHROME.</span></p>
    </div>

    <div class="header">
        <h1 class="title">QUANTUM V4.3</h1>
        <div class="subtitle" id="status">Connecting to Neural Core...</div>
    </div>

    <div class="dashboard">
        <div class="glass-card">
            <div class="metrics">
                <div class="metric-box">
                    <div class="m-label">Target Period</div>
                    <div class="m-val" id="period">----</div>
                </div>
                <div style="width: 1px; height: 40px; background: var(--glass-border);"></div>
                <div class="metric-box">
                    <div class="m-label">Win Rate</div>
                    <div class="m-val" id="winrate" style="color: var(--green);">--%</div>
                </div>
            </div>

            <div class="pred-container">
                <div class="m-label">Active AI Signal</div>
                <div class="pred-target c-WAIT" id="action">LOADING</div>
                
                <div class="prob-bar-bg">
                    <div class="prob-bar-fill" id="probBar"></div>
                </div>
                <div style="display:flex; justify-content:space-between; font-size:11px; color:#aaa; margin-top:8px; font-weight:700;">
                    <span>ALGORITHMIC CONFIDENCE</span>
                    <span id="probText" style="color: var(--cyan);">0%</span>
                </div>
            </div>
        </div>

        <div class="terminal" id="logBox"></div>

        <button class="btn-reset" onclick="forceReset()">[ PURGE SYSTEM MEMORY ]</button>
    </div>

<script>
if (window.location.href.includes("zarchiver") || window.location.href.includes("content://")) {
    document.getElementById("blocker").style.display = "flex";
    throw new Error("Execution halted. Unsupported previewer environment.");
}

// ==========================================
// âš™ï¸ TELEGRAM CONFIGURATION
// ==========================================
const BOT_TOKEN = "8561861801:AAE8stFdYnAYuiXURg5esS-caURtIzx6gRg";
const TARGET_CHATS = ["1669843747", "-1002613316641"];
const API = "https://draw.ar-lottery01.com/WinGo/WinGo_1M/GetHistoryIssuePage.json?pageNo=1&pageSize=30";

// ==========================================
// ğŸ§  MEMORY & STATE
// ==========================================
let state = JSON.parse(localStorage.getItem("kira_quantum_v4_3")) || {
    lastProcessedIssue: null,
    activePrediction: null, 
    totalSignals: 0,
    wins: 0,
    isStarted: false 
};

function saveState() { localStorage.setItem("kira_quantum_v4_3", JSON.stringify(state)); }

function forceReset() {
    if(confirm("WARNING: This will wipe AI history and win rates. Proceed?")) {
        state = { lastProcessedIssue: null, activePrediction: null, totalSignals: 0, wins: 0, isStarted: false };
        saveState(); location.reload();
    }
}

let isProcessing = false; 

function log(msg, type="info") {
    const box = document.getElementById("logBox");
    let colorClass = "t-info";
    if(type === "wait") colorClass = "t-warn";
    if(type === "success") colorClass = "t-success";
    if(type === "error") colorClass = "t-err";
    if(type === "mem") colorClass = "t-mem";
    
    let time = new Date().toLocaleTimeString('en-US', { hour12: false });
    box.innerHTML += `<div class="log-row"><span class="t-time">[${time}]</span> <span class="${colorClass}">${msg}</span></div>`;
    box.scrollTop = box.scrollHeight;
}

// ==========================================
// ğŸ“¨ VIP TELEGRAM SENDER
// ==========================================
async function sendTelegram(text) {
    for(let chat_id of TARGET_CHATS) {
        try {
            await fetch(`https://api.telegram.org/bot${BOT_TOKEN}/sendMessage`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ chat_id: chat_id, text: text, parse_mode: 'HTML' })
            });
        } catch(e) { }
    }
}

function updateUI(prediction, period, conf = 0) {
    document.getElementById("action").innerText = prediction;
    document.getElementById("action").className = `pred-target c-${prediction}`;
    if(period) document.getElementById("period").innerText = period.slice(-4);
    
    document.getElementById("probBar").style.width = `${conf}%`;
    document.getElementById("probText").innerText = `${conf}%`;

    let wr = state.totalSignals > 0 ? Math.round((state.wins / state.totalSignals) * 100) : 0;
    document.getElementById("winrate").innerText = `${wr}%`;
}

window.onload = () => {
    log("Quantum Core V4.3 Initializing...", "info");
    if (!state.isStarted) {
        let bootMsg = `ğŸŸ¢ <b>KIRA QUANTUM V4.3 ONLINE</b> ğŸŸ¢\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\nğŸ“¡ <i>Neural Core Activated.\nActive Trading Mode Engaged...</i>`;
        sendTelegram(bootMsg);
        state.isStarted = true; saveState();
    }
    if(state.activePrediction) {
        updateUI(state.activePrediction.pred, state.activePrediction.period, state.activePrediction.conf);
        log(`Memory Restored. Pending Bet: ${state.activePrediction.pred}`, "mem");
    }
    updateUI(
        state.activePrediction ? state.activePrediction.pred : "WAIT", 
        state.lastProcessedIssue ? (BigInt(state.lastProcessedIssue)+1n).toString() : "----", 
        state.activePrediction ? state.activePrediction.conf : 0
    );
};

// ==========================================
// ğŸ§  QUANTUM V4.3 BRAIN (ACTIVE TRADING MODE)
// ==========================================
function getSize(n) { return n <= 4 ? "SMALL" : "BIG"; }

function analyzeQuantum(list) {
    if(!list || list.length < 5) return { action: "WAIT", conf: 0, reason: "NOT ENOUGH DATA" };
    
    const sizes = list.map(i => getSize(Number(i.number))); 
    let prediction = "WAIT";
    let confidence = 0;
    let analysisText = "";

    // 1. PLAY THE CHOP (Alternating Market)
    let chopCount = 0;
    for(let i=0; i < 4; i++) { if(sizes[i] !== sizes[i+1]) chopCount++; }
    
    if(chopCount >= 3) {
        prediction = sizes[0] === "BIG" ? "SMALL" : "BIG";
        confidence = 75 + (chopCount * 2);
        analysisText = "Alternating Market (Chop Play)";
        return { action: prediction, conf: Math.min(confidence, 92), reason: analysisText };
    }

    // 2. STREAK LOGIC
    let streak = 1;
    for(let i=1; i<sizes.length; i++) { if(sizes[i] === sizes[0]) streak++; else break; }
    
    if(streak >= 2) {
        if(streak >= 5) {
            // Reversal if the streak is too long
            prediction = sizes[0] === "BIG" ? "SMALL" : "BIG";
            confidence = 80 + streak;
            analysisText = "Streak Exhaustion / Flip";
        } else {
            // Trend Follow
            prediction = sizes[0];
            confidence = 78 + (streak * 2);
            analysisText = "Strong Trend Continuation";
        }
        return { action: prediction, conf: Math.min(confidence, 96), reason: analysisText };
    }

    // 3. STATISTICAL PROBABILITY (For messy, non-pattern markets)
    let bigToBig = 0, bigToSmall = 0, smallToSmall = 0, smallToBig = 0;
    let chainLength = Math.min(20, sizes.length - 1);
    for(let i=0; i < chainLength; i++) {
        let current = sizes[i], previous = sizes[i+1]; 
        if(previous === "BIG" && current === "BIG") bigToBig++;
        if(previous === "BIG" && current === "SMALL") bigToSmall++;
        if(previous === "SMALL" && current === "SMALL") smallToSmall++;
        if(previous === "SMALL" && current === "BIG") smallToBig++;
    }

    if (sizes[0] === "BIG") {
        let total = bigToBig + bigToSmall;
        if(total > 0) {
            let probStayBig = (bigToBig / total) * 100;
            if(probStayBig > 50) { prediction = "BIG"; confidence = probStayBig; analysisText = "Statistical Trend Bias"; }
            else if(probStayBig < 50) { prediction = "SMALL"; confidence = 100 - probStayBig; analysisText = "Statistical Flip Bias"; }
        }
    } else {
        let total = smallToSmall + smallToBig;
        if(total > 0) {
            let probStaySmall = (smallToSmall / total) * 100;
            if(probStaySmall > 50) { prediction = "SMALL"; confidence = probStaySmall; analysisText = "Statistical Trend Bias"; }
            else if(probStaySmall < 50) { prediction = "BIG"; confidence = 100 - probStaySmall; analysisText = "Statistical Flip Bias"; }
        }
    }

    // Boost base confidence so it actively trades
    confidence += 20; 
    confidence = Math.min(Math.round(confidence), 95); 

    // It will now ONLY wait if it is exactly a dead 50/50 tie.
    if(confidence >= 65 && prediction !== "WAIT") {
        return { action: prediction, conf: confidence, reason: analysisText };
    }

    return { action: "WAIT", conf: 0, reason: "EXACT 50/50 DEADLOCK" };
}

// ==========================================
// âš™ï¸ SYSTEM LOOP
// ==========================================
async function tick() {
    if(isProcessing) return; 
    isProcessing = true;

    try {
        const res = await fetch(API + "&_t=" + Date.now());
        const data = await res.json();
        const list = data.data.list;
        
        const latestIssue = list[0].issueNumber;
        const targetIssue = (BigInt(latestIssue) + 1n).toString();
        
        document.getElementById("status").innerText = "MATRIX LIVE: SCANNING ALGORITHMS...";

        // 1ï¸âƒ£ CHECK PREVIOUS RESULT
        if(state.activePrediction) {
            if(BigInt(latestIssue) >= BigInt(state.activePrediction.period)) {
                
                const resultItem = list.find(i => i.issueNumber === state.activePrediction.period);
                
                if(resultItem) {
                    let actualNum = Number(resultItem.number);
                    let actualResult = getSize(actualNum);
                    let isWin = (actualResult === state.activePrediction.pred);
                    
                    state.totalSignals++;
                    if(isWin) state.wins++;
                    let currentAccuracy = Math.round((state.wins / state.totalSignals) * 100);
                    
                    let resMsg = isWin ? `âœ… <b>ğ“ğ€ğ‘ğ†ğ„ğ“ ğ„ğ‹ğˆğŒğˆğğ€ğ“ğ„ğƒ</b> âœ…\n` : `âŒ <b>ğ“ğ€ğ‘ğ†ğ„ğ“ ğŒğˆğ’ğ’ğ„ğƒ</b> âŒ\n`;
                    resMsg += `â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n`;
                    resMsg += `ğŸ¯ ğğğ«ğ¢ğ¨ğ: <code>${state.activePrediction.period.slice(-4)}</code>\n`;
                    resMsg += `ğŸ² ğ‘ğğ¬ğ®ğ¥ğ­: <b>${actualNum} (${actualResult})</b>\n`;
                    if(isWin) resMsg += `ğŸ’° ğ’ğ­ğšğ­ğ®ğ¬: <b>PROFIT SECURED!</b> ğŸ’¸\n`;
                    else resMsg += `ğŸ›¡ï¸ ğ’ğ­ğšğ­ğ®ğ¬: Leveling up next phase...\n`;
                    resMsg += `ğŸ“ˆ ğ€ğœğœğ®ğ«ğšğœğ²: ${currentAccuracy}%\n`;
                    resMsg += `â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”`;

                    await sendTelegram(resMsg);
                    log(`Period ${state.activePrediction.period.slice(-4)} | Result: ${isWin ? 'WIN âœ…' : 'LOSS âŒ'}`, isWin ? 'success' : 'error');
                } 
                
                state.activePrediction = null;
                updateUI("WAIT", targetIssue, 0);
                saveState();
            }
        }

        // 2ï¸âƒ£ GENERATE NEW PREDICTION
        if(state.lastProcessedIssue !== latestIssue) {
            
            if(!state.activePrediction) {
                log(`Analyzing New Period: ${targetIssue.slice(-4)}...`, "info");
                const signal = analyzeQuantum(list);
                
                if(signal) {
                    if(signal.action === "WAIT") {
                        let msg = `â¸ <b>ğŒğ€ğ‘ğŠğ„ğ“ ğ’ğ‚ğ€ğ | ğğğ«ğ¢ğ¨ğ: ${targetIssue.slice(-4)}</b>\n\n`;
                        msg += `âš ï¸ <b>ğ€ğœğ­ğ¢ğ¨ğ§:</b> WAIT\n`;
                        msg += `ğŸ“‰ <b>ğ‘ğğšğ¬ğ¨ğ§:</b> ${signal.reason}\n`;
                        
                        await sendTelegram(msg);
                        log(`Analysis: ${signal.reason} -> WAIT`, "wait");
                        updateUI("WAIT", targetIssue, 0);
                    } else {
                        let riskLevel = signal.conf > 85 ? "ğŸŸ¢ Low Risk" : "ğŸŸ¡ Med Risk";
                        
                        let msg = `âš¡ï¸ ğŠğˆğ‘ğ€ ğğ”ğ€ğğ“ğ”ğŒ ğ€ğˆ âš¡ï¸\n`;
                        msg += `â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n`;
                        msg += `ğŸ¯ ğğğ«ğ¢ğ¨ğ: <code>${targetIssue.slice(-4)}</code>\n`;
                        msg += `ğŸ”® ğ’ğ¢ğ ğ§ğšğ¥: <b>${signal.action}</b>\n`;
                        msg += `ğŸ›¡ï¸ ğ‘ğ¢ğ¬ğ¤: ${riskLevel}\n`;
                        msg += `ğŸ“Š ğ‚ğ¨ğ§ğŸğ¢ğğğ§ğœğ: ${signal.conf}%\n`;
                        msg += `â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n`;
                        msg += `ğŸ’¡ <i>${signal.reason}</i>\n`;
                        msg += `ğŸ’° <i>Bet according to your fund management.</i>`;
                        
                        await sendTelegram(msg);
                        
                        updateUI(signal.action, targetIssue, signal.conf);
                        log(`Signal Fired: ${signal.action} (${signal.conf}%)`, "success");
                        
                        state.activePrediction = { period: targetIssue, pred: signal.action, conf: signal.conf };
                        saveState();
                    }
                }
            }
            
            state.lastProcessedIssue = latestIssue;
            saveState();
        }

    } catch (e) {
        document.getElementById("status").innerText = "âš ï¸ SYSTEM INTERFERENCE: RETRYING...";
    } finally {
        isProcessing = false; 
    }
}

setInterval(tick, 2000);
tick(); 

</script>
</body>
</html>
